<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rocket League Chatlog Viewer</title> <!-- Updated title -->
  <!-- Favicon embedded as base64 data URI -->
  <link rel="icon" type="image/x-icon" href="data:image/x-icon;base64,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">
  <style>
    /* Basic Reset and Body Styles */
    html {
      margin: 0;
      padding: 0;
      font-size: 16px; /* Base font size */
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background-color: #f0f2f5; /* Light grey background */
      color: #1a202c; /* Darker text for better contrast */
      min-height: 100vh;
      margin: 0;
      padding: 20px; /* Padding around the entire page content */
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center; /* Center content like h1, input, chat-container */
    }

    /* Page Title */
    h1 {
      color: #2d3748; /* Slightly darker title color */
      margin-top: 0; /* Body padding handles top space */
      margin-bottom: 24px;
      font-size: 1.75rem; /* Larger title */
      font-weight: 700;
      text-align: center;
    }

    /* File Input */
    input[type="file"] {
      display: block;
      margin: 0 auto 24px auto; /* Centering and bottom margin */
      padding: 12px 18px;
      border-radius: 8px;
      border: 1px solid #cbd5e0; /* Softer border */
      background-color: #ffffff;
      cursor: pointer;
      font-size: 0.9rem;
      color: #4a5568;
      transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    }
    input[type="file"]:hover {
      border-color: #a0aec0;
    }
    input[type="file"]:focus {
      outline: none;
      border-color: #4299e1; /* Blue border on focus */
      box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);
    }

    /* Filter Containers for Dropdowns */
    .filters-container {
      display: flex;
      flex-direction: column; /* Stack date filters above match filters */
      align-items: center; /* Center horizontally */
      margin-bottom: 20px;
      max-width: 700px;
      width: 100%;
      box-sizing: border-box;
      display: none; /* Hidden by default */
    }
    /* Styles for when filters-container is visible */
    .filters-container.visible {
        display: flex;
    }


    .filter-group {
        display: flex;
        align-items: center;
        gap: 10px; /* Space between label and dropdown */
        margin-bottom: 15px; /* Space between filter groups */
        flex-wrap: wrap; /* Allow wrapping on small screens */
        justify-content: center;
    }

    .filter-label {
        font-size: 0.9rem;
        color: #4a5568;
        font-weight: 500;
    }

    .filter-dropdown {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid #cbd5e0;
      background-color: #ffffff;
      color: #1a202c;
      font-size: 0.9rem;
      cursor: pointer;
      transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
      min-width: 150px; /* Ensure a decent minimum width */
    }
    .filter-dropdown:hover {
      border-color: #a0aec0;
    }
    .filter-dropdown:focus {
      outline: none;
      border-color: #4299e1;
      box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);
    }

    /* Main Chat Container */
    .chat-container {
      background-color: #ffffff;
      border-radius: 12px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08); /* Softer shadow */
      padding: 20px; /* Padding inside the container */
      width: 100%; /* Responsive width */
      max-width: 600px; /* Reduced width as per request */
      margin-left: auto;
      margin-right: auto;
      box-sizing: border-box;
      overflow-y: auto; /* Scroll for long chats */
    }

    /* Match Break Line Styling */
    .match-break-line {
      margin: 30px 5%; /* Vertical and some horizontal margin */
      text-align: center;
      position: relative; /* For pseudo-element positioning */
    }
    .match-break-line::before {
      content: "";
      display: block;
      border-top: 2px dashed #adb5bd; /* Slightly darker dashed line */
      position: absolute;
      left: 0;
      right: 0;
      top: 50%;
      z-index: 1; /* Ensure line is behind the text */
    }
    .match-break-line span {
      background-color: #ffffff; /* Match chat container background to "cut through" the line */
      padding: 0 15px;
      font-size: 0.75rem;
      font-weight: 500;
      color: #6c757d; /* Grey text */
      position: relative;
      z-index: 2; /* Ensure text is above the line */
      display: inline-block;
    }

    /* Timestamp Grouping for Dates */
    .date-group-timestamp {
      text-align: center;
      font-size: 0.8rem;
      font-weight: 500;
      color: #4a5568;
      margin: 24px 0 12px 0;
      padding: 4px 8px;
      background-color: #e2e8f0;
      border-radius: 12px;
      display: inline-block;
      left: 50%;
      position: relative;
      transform: translateX(-50%);
    }

    /* Individual Chat Entry Block (contains name, bubbles, meta) */
    .chat-entry {
      display: flex;
      flex-direction: column;
      margin-top: 10px;
      margin-bottom: 15px;
      max-width: 80%;
      box-sizing: border-box;
      position: relative;
    }

    /* Alignment for 'me'/'teammate' vs 'opponent' entries */
    .chat-entry.me, .chat-entry.teammate {
      margin-left: auto;
      margin-right: 0;
      align-items: flex-end;
    }
    .chat-entry.opponent {
      margin-left: 0;
      margin-right: auto;
      align-items: flex-start;
    }

    /* Player Name Badge */
    .player-name-badge {
      font-weight: 500;
      margin-bottom: 5px;
      font-size: 0.8rem;
      color: #4a5568;
      padding: 0 2px;
    }

    /* Wrapper for multiple bubbles from the same user in a group */
    .chat-bubbles-wrapper {
      display: flex;
      flex-direction: column;
      width: auto;
      gap: 4px;
    }

    /* Individual Chat Bubble Styling */
    .chat-bubble {
      font-size: 1.05rem;
      padding: 10px 14px;
      border-radius: 18px;
      display: inline-block;
      word-wrap: break-word;
      overflow-wrap: break-word;
      max-width: 100%;
      line-height: 1.4;
      box-sizing: border-box;
      text-align: left;
      white-space: pre-wrap;
    }

    /* My messages: Blue */
    .chat-entry.me .chat-bubble {
      background-color: #3b82f6;
      color: white;
      border-bottom-right-radius: 6px;
    }

    /* Teammate messages: Green */
    .chat-entry.teammate .chat-bubble {
      background-color: #10b981;
      color: white;
      border-bottom-right-radius: 6px;
    }

    /* Opponent messages: Red */
    .chat-entry.opponent .chat-bubble {
      background-color: #ef4444;
      color: white;
      border-bottom-left-radius: 6px;
    }

    /* Meta Information (Platform, Time) */
    .chat-meta {
      font-size: 0.7rem;
      color: #718096;
      margin-top: 5px;
      padding: 0 2px;
    }

    /* Placeholder/Info Message */
    .info-message {
      text-align: center;
      color: #718096;
      padding: 20px;
      font-style: italic;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <h1>Rocket League Chatlog Viewer</h1>
  <input type="file" id="chatfile" accept=".json">
  <div class="filters-container" id="filters-container">
    <div class="filter-group">
        <label for="date-select" class="filter-label">Filter by Date:</label>
        <select id="date-select" class="filter-dropdown"></select>
    </div>
    <div class="filter-group">
        <label for="match-select" class="filter-label">Filter by Match:</label>
        <select id="match-select" class="filter-dropdown"></select>
    </div>
  </div>
  <div class="chat-container" id="chatlog">
    <div class="info-message">Upload a Rocket League chatlog JSON file to view messages.</div>
  </div>

  <script>
    // Global variables for chat data and filter states
    let storedChatMessages = []; // Stores the raw, full chat data from the uploaded file
    let uniqueDates = []; // Stores sorted unique date strings
    let matchSegments = []; // Stores identified match segments: { date: string, label: string, startIndex: number, endIndex: number }

    // DOM references for convenience
    const dateSelect = document.getElementById('date-select');
    const matchSelect = document.getElementById('match-select');
    const chatlogContainer = document.getElementById('chatlog');
    const filtersContainer = document.getElementById('filters-container'); // Reference to the main filters container

    // --- Constants for chat rendering and match detection logic ---
    const GG_QUIET_PERIOD_MS = 15 * 1000; // 15 seconds after a 'gg' or subsequent message in that sequence
    const MAJOR_GROUP_TIME_GAP_MS = 60 * 1000; // 1 minute for a new player/group within a match
    const BUBBLE_CONCATENATION_MS = 5 * 1000; // 5 seconds to concatenate messages in same bubble
    const GG_FOLLOWUP_GRACE_PERIOD_MS = 30 * 1000; // Time within which non-gg messages still extend the 'end-of-game' potential

    /**
     * Pre-processes the entire chat data to identify unique dates and match segments.
     * This function runs once after the file is loaded.
     * @param {Array<Object>} allMessages - The full array of chat message objects from the JSON.
     */
    function preprocessChatData(allMessages) {
        uniqueDates = new Set();
        matchSegments = [];
        
        if (!allMessages || allMessages.length === 0) return;

        let currentMatchStartIndex = 0;
        let matchCounterForDate = 0; // Incremented for each match on a given date
        
        let lastPlayerName = null;
        let lastRelevantMessageTimestamp = null; // Timestamp of the last *valid* message processed
        let lastRelationClass = null;
        let potentialMatchEndTimestamp = null; // Timestamp of the latest 'gg' or valid followup message
        let lastDateString = null; // For tracking date changes

        // To ensure consistent date formatting for comparison
        const formatAsDateString = (date) => date.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' });

        allMessages.forEach((entry, index) => {
            // Basic validation for entries during preprocessing
            if (!entry || typeof entry.chat !== 'string' || typeof entry.playerName !== 'string' || typeof entry.time !== 'string' || typeof entry.relation !== 'string' || entry.chat.trim() === "" || isNaN(new Date(entry.time).getTime())) {
                return; // Skip malformed entries and don't affect state
            }

            const currentTimestamp = new Date(entry.time);
            const currentDateString = formatAsDateString(currentTimestamp);
            uniqueDates.add(currentDateString); // Collect all unique dates

            // --- Match Break Detection Logic (same as renderChatlog, but for preprocessing) ---
            let shouldInsertMatchBreak = false;
            if (potentialMatchEndTimestamp !== null) {
                // If there's a potential end-of-match sequence active, check for quiet period
                if (currentTimestamp.getTime() - potentialMatchEndTimestamp.getTime() > GG_QUIET_PERIOD_MS) {
                    shouldInsertMatchBreak = true;
                }
            }

            // Check if date has changed, if so, this implies a new match segment
            const isNewDate = lastDateString !== null && currentDateString !== lastDateString;
            if (isNewDate) {
                // If date changes, force a match break for the *previous* date's last segment
                if (index > currentMatchStartIndex) { // Only if a segment was started
                     matchSegments.push({
                        date: lastDateString,
                        label: `Match ${++matchCounterForDate}`,
                        startIndex: currentMatchStartIndex,
                        endIndex: index - 1 // End at the message *before* the date change
                    });
                }
                currentMatchStartIndex = index; // Start new segment at current index
                matchCounterForDate = 0; // Reset match counter for the new date
                potentialMatchEndTimestamp = null; // Reset potential match end for new date
            } else if (shouldInsertMatchBreak) {
                // If a quiet period was met, end the previous match segment
                if (index > currentMatchStartIndex) { // Only if a segment was started
                    matchSegments.push({
                        date: currentDateString, // Use the date of the messages in this segment
                        label: `Match ${++matchCounterForDate}`,
                        startIndex: currentMatchStartIndex,
                        endIndex: index - 1 // End at the message *before* the detected break
                    });
                }
                currentMatchStartIndex = index; // Start new segment from current index
                potentialMatchEndTimestamp = null; // Reset for the new match
            }

            // --- Update potentialMatchEndTimestamp based on current message ---
            const isGgMessage = entry.chat.toLowerCase() === 'gg';
            if (isGgMessage) {
                potentialMatchEndTimestamp = currentTimestamp;
            } else if (potentialMatchEndTimestamp !== null) {
                if (currentTimestamp.getTime() - potentialMatchEndTimestamp.getTime() <= GG_FOLLOWUP_GRACE_PERIOD_MS) {
                    potentialMatchEndTimestamp = currentTimestamp;
                } else {
                    potentialMatchEndTimestamp = null; // End 'gg' sequence if grace period exceeded
                }
            }

            // Update tracking variables for the next iteration's match break logic
            lastRelevantMessageTimestamp = currentTimestamp;
            lastDateString = currentDateString; // Update last date string for next iteration
        });

        // Add the very last match segment after loop finishes
        if (allMessages.length > currentMatchStartIndex) {
            matchSegments.push({
                date: lastDateString, // Use the date of the last segment
                label: `Match ${++matchCounterForDate}`,
                startIndex: currentMatchStartIndex,
                endIndex: allMessages.length - 1
            });
        }
        
        // Convert set to array and sort unique dates
        uniqueDates = Array.from(uniqueDates).sort((a, b) => new Date(a) - new Date(b));
    }


    /**
     * Renders the chat log based on the provided messages.
     * This function now contains the core logic for displaying messages,
     * handling date grouping, match breaks, and message concatenation.
     * @param {Array<Object>} messagesToDisplay - The array of chat message objects to render.
     * @param {boolean} displayMatchBreaks - Whether to insert "New Match" separators. True for full log/date view, false for single match view.
     */
    function renderChatlog(messagesToDisplay, displayMatchBreaks = true) {
      chatlogContainer.innerHTML = ''; // Clear previous chat/placeholder

      if (!messagesToDisplay || messagesToDisplay.length === 0) {
        chatlogContainer.innerHTML = '<div class="info-message">No chat messages to display for the selected filter.</div>';
        return;
      }

      // Reset state variables for each render, crucial for filtering
      let lastPlayerName = null;
      let lastRelevantMessageTimestamp = null;
      let lastRelationClass = null;
      let currentGroupEntryDiv = null;
      let bubblesWrapper = null;
      let currentGroupMetaDiv = null;
      let lastBubbleContentElement = null;
      let lastBubbleTimestamp = null;
      let lastDateString = null; // For date grouping header
      let potentialMatchEndTimestamp = null; // For rendering match breaks

      // Only show date group header if it's the very first message of the displayed set,
      // or if it's a new date in an "All Dates" or "All Matches for a Date" view.
      let firstMessageRendered = false;

      messagesToDisplay.forEach((entry, index) => {
        // Basic validation for critical fields (should ideally be handled during initial parse)
        if (!entry || typeof entry.chat !== 'string' || typeof entry.playerName !== 'string' || typeof entry.time !== 'string' || typeof entry.relation !== 'string') {
             console.warn('Skipping malformed chat entry:', entry);
             return;
        }
        if (entry.chat.trim() === "") {
            return;
        }

        const currentTimestamp = new Date(entry.time);
        if (isNaN(currentTimestamp.getTime())) {
            console.warn('Skipping entry with invalid time:', entry);
            return;
        }

        // --- Match Break Logic (only if displayMatchBreaks is true) ---
        let shouldInsertMatchBreak = false;
        if (displayMatchBreaks && potentialMatchEndTimestamp !== null) {
            if (currentTimestamp.getTime() - potentialMatchEndTimestamp.getTime() > GG_QUIET_PERIOD_MS) {
                shouldInsertMatchBreak = true;
            }
        }

        if (shouldInsertMatchBreak) {
            const matchBreakDiv = document.createElement('div');
            matchBreakDiv.className = 'match-break-line';
            const matchBreakSpan = document.createElement('span');
            matchBreakSpan.textContent = 'New Match';
            matchBreakDiv.appendChild(matchBreakSpan);
            chatlogContainer.appendChild(matchBreakDiv);

            // Reset state for new match segment during rendering
            lastPlayerName = null;
            lastDateString = null; // Reset lastDateString to force new date header if needed
            lastRelationClass = null;
            currentGroupEntryDiv = null;
            bubblesWrapper = null;
            currentGroupMetaDiv = null;
            lastBubbleContentElement = null;
            lastBubbleTimestamp = null;
            potentialMatchEndTimestamp = null;
            lastRelevantMessageTimestamp = null;
        }

        // --- Update potentialMatchEndTimestamp based on current message ---
        const isGgMessage = entry.chat.toLowerCase() === 'gg';
        if (isGgMessage) {
            potentialMatchEndTimestamp = currentTimestamp;
        } else if (potentialMatchEndTimestamp !== null) {
            if (currentTimestamp.getTime() - potentialMatchEndTimestamp.getTime() <= GG_FOLLOWUP_GRACE_PERIOD_MS) {
                potentialMatchEndTimestamp = currentTimestamp;
            } else {
                potentialMatchEndTimestamp = null;
            }
        }

        // --- Date Grouping ---
        const currentDateString = currentTimestamp.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' });
        // Show date header if it's the first message overall, or if date changed AND we're displaying breaks
        if (!firstMessageRendered || (displayMatchBreaks && currentDateString !== lastDateString)) {
            const dateGroupDiv = document.createElement('div');
            dateGroupDiv.className = 'date-group-timestamp';
            dateGroupDiv.textContent = currentDateString;
            chatlogContainer.appendChild(dateGroupDiv);
            lastDateString = currentDateString;
            firstMessageRendered = true; // Mark that at least one message has been rendered
            // Force new player group after date change
            lastPlayerName = null;
        }

        // --- Determine if a NEW MAJOR GROUP (player name badge, meta line) is needed ---
        const timeSinceLastMajorGroupMessage = lastRelevantMessageTimestamp ? currentTimestamp.getTime() - lastRelevantMessageTimestamp.getTime() : Infinity;
        const isNewMajorGroup = !lastPlayerName ||
                                lastPlayerName !== entry.playerName ||
                                lastRelationClass !== entry.relation.toLowerCase() ||
                                timeSinceLastMajorGroupMessage > MAJOR_GROUP_TIME_GAP_MS;

        if (isNewMajorGroup) {
          currentGroupEntryDiv = document.createElement('div');
          currentGroupEntryDiv.className = `chat-entry ${entry.relation.toLowerCase()}`;
          
          const playerNameBadge = document.createElement('div');
          playerNameBadge.className = 'player-name-badge';
          playerNameBadge.textContent = entry.playerName;
          currentGroupEntryDiv.appendChild(playerNameBadge);

          bubblesWrapper = document.createElement('div');
          bubblesWrapper.className = 'chat-bubbles-wrapper';
          currentGroupEntryDiv.appendChild(bubblesWrapper);

          currentGroupMetaDiv = document.createElement('div');
          currentGroupMetaDiv.className = 'chat-meta';
          currentGroupEntryDiv.appendChild(currentGroupMetaDiv); 

          chatlogContainer.appendChild(currentGroupEntryDiv);

          lastBubbleContentElement = null;
          lastBubbleTimestamp = null;
        }

        // --- Condition for concatenating into the *last bubble* ---
        const canConcatenateToLastBubble = lastBubbleContentElement &&
                                           lastBubbleTimestamp && 
                                           (currentTimestamp.getTime() - lastBubbleTimestamp.getTime()) <= BUBBLE_CONCATENATION_MS;

        if (canConcatenateToLastBubble) {
          lastBubbleContentElement.textContent += '\n' + entry.chat; 
        } else {
          const newChatBubble = document.createElement('div');
          newChatBubble.className = 'chat-bubble'; 
          newChatBubble.textContent = entry.chat;
          bubblesWrapper.appendChild(newChatBubble);
          lastBubbleContentElement = newChatBubble; 
        }
        
        // --- Update meta-info for the current major group ---
        const timeString = currentTimestamp.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true });
        currentGroupMetaDiv.textContent = `${timeString} · ${entry.platform || 'N/A'}`;

        // --- Update trackers for the next iteration ---
        lastPlayerName = entry.playerName;
        lastRelationClass = entry.relation.toLowerCase();
        lastBubbleTimestamp = currentTimestamp;
        lastRelevantMessageTimestamp = currentTimestamp;
      });
      
      // Display info message if no valid chat messages were processed after all filtering
      if (chatlogContainer.children.length === 0 || 
          (chatlogContainer.children.length === 1 && 
           (chatlogContainer.firstChild.classList.contains('date-group-timestamp') || chatlogContainer.firstChild.classList.contains('match-break-line')) && 
           !chatlogContainer.firstChild.nextSibling) ) { 
         if (!chatlogContainer.querySelector('.chat-entry')) { 
            chatlogContainer.innerHTML = '<div class="info-message">No valid chat messages to display after filtering.</div>';
         }
      }
    }


    /**
     * Populates the date filter dropdown based on unique dates in the chat messages.
     */
    function populateDateFilters() {
        dateSelect.innerHTML = ''; // Clear existing options

        // Add "All Dates" option
        const allDatesOption = document.createElement('option');
        allDatesOption.value = 'all';
        allDatesOption.textContent = 'All Dates';
        dateSelect.appendChild(allDatesOption);

        // Add options for each unique date
        uniqueDates.forEach(dateString => {
            const option = document.createElement('option');
            option.value = dateString;
            option.textContent = dateString;
            dateSelect.appendChild(option);
        });

        // Set initial selected value
        dateSelect.value = 'all';

        // Event listener for date selection change
        dateSelect.onchange = () => {
            const selectedDateValue = dateSelect.value;
            currentSelectedDate = (selectedDateValue === 'all') ? null : selectedDateValue;
            currentSelectedMatch = null; // Reset match filter when date changes

            const messagesToRender = (currentSelectedDate === null) ? storedChatMessages : storedChatMessages.filter(entry => {
                const entryDate = new Date(entry.time);
                return !isNaN(entryDate.getTime()) && entryDate.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' }) === currentSelectedDate;
            });
            renderChatlog(messagesToRender, true); // Render filtered messages, show match breaks
            populateMatchFilters(currentSelectedDate); // Update match dropdown
        };

        // Populate match filters for the initially selected date (All Dates)
        populateMatchFilters(null);
    }

    /**
     * Populates the match filter dropdown based on the selected date.
     * @param {string|null} dateFilter - The date string to filter matches by, or null for all dates.
     */
    function populateMatchFilters(dateFilter) {
        matchSelect.innerHTML = ''; // Clear existing options

        let matchesForDisplay = [];
        if (dateFilter === null) {
            matchesForDisplay = matchSegments; // Show all matches from all dates
        } else {
            matchesForDisplay = matchSegments.filter(match => match.date === dateFilter);
        }

        // Add "All Matches" option
        const allMatchesOption = document.createElement('option');
        allMatchesOption.value = 'all';
        allMatchesOption.textContent = 'All Matches';
        matchSelect.appendChild(allMatchesOption);

        if (matchesForDisplay.length === 0) {
            // If no matches, just "All Matches" option will be there.
            // Disable dropdown if no matches found.
            matchSelect.disabled = true;
        } else {
            matchSelect.disabled = false;
            // Add options for each match segment
            matchesForDisplay.forEach((match, index) => {
                const option = document.createElement('option');
                option.value = index; // Use index to reference the match segment in matchesForDisplay
                // If a specific date is selected, just show "Match X", otherwise show "Date Match X"
                if (dateFilter !== null) { 
                    option.textContent = match.label;
                } else {
                    option.textContent = `${match.date} ${match.label}`; 
                }
                matchSelect.appendChild(option);
            });
        }

        // Set initial selected value
        matchSelect.value = 'all';

        // Event listener for match selection change
        matchSelect.onchange = () => {
            const selectedMatchValue = matchSelect.value;
            if (selectedMatchValue === 'all') {
                currentSelectedMatch = null; // Clear specific match filter
                const messagesToRender = (currentSelectedDate === null) ? storedChatMessages : storedChatMessages.filter(entry => {
                    const entryDate = new Date(entry.time);
                    return !isNaN(entryDate.getTime()) && entryDate.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' }) === currentSelectedDate;
                });
                renderChatlog(messagesToRender, true); // Render all matches for the date (or all dates), show breaks
            } else {
                const selectedMatchIndex = parseInt(selectedMatchValue);
                currentSelectedMatch = matchesForDisplay[selectedMatchIndex];
                const messagesToRender = storedChatMessages.slice(currentSelectedMatch.startIndex, currentSelectedMatch.endIndex + 1);
                renderChatlog(messagesToRender, false); // Render single match, *hide* match breaks
            }
        };
    }


    // --- Initial setup and Event Listener for file input ---
    document.addEventListener('DOMContentLoaded', () => {
        // Initial state: clear dropdowns and disable them until a file is loaded
        dateSelect.innerHTML = '';
        matchSelect.innerHTML = '';
        dateSelect.disabled = true;
        matchSelect.disabled = true;
        filtersContainer.classList.remove('visible'); // Ensure filters are hidden on load
    });


    document.getElementById('chatfile').addEventListener('change', function(event) {
      const file = event.target.files[0];
      
      if (!file) {
        return;
      }

      chatlogContainer.innerHTML = '<div class="info-message">Processing chat log...</div>';
      dateSelect.innerHTML = ''; // Clear dropdowns during processing
      matchSelect.innerHTML = '';
      dateSelect.disabled = true; // Disable during processing
      matchSelect.disabled = true;
      filtersContainer.classList.remove('visible'); // Hide filters during processing


      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const jsonData = JSON.parse(e.target.result);
          if (!jsonData || !Array.isArray(jsonData.chatMessages)) {
            chatlogContainer.innerHTML = '<div class="info-message">No chat messages array found in the file, or the file is not in the expected format.</div>';
            storedChatMessages = [];
            dateSelect.innerHTML = '';
            matchSelect.innerHTML = '';
            dateSelect.disabled = true;
            matchSelect.disabled = true;
            filtersContainer.classList.remove('visible'); // Keep hidden on error
            return;
          }
          storedChatMessages = jsonData.chatMessages;

          if (storedChatMessages.length === 0) {
             chatlogContainer.innerHTML = '<div class="info-message">No chat messages found in the file.</div>';
             dateSelect.innerHTML = '';
             matchSelect.innerHTML = '';
             dateSelect.disabled = true;
             matchSelect.disabled = true;
             filtersContainer.classList.remove('visible'); // Keep hidden if no messages
             return;
          }

          // Preprocess all chat data to identify dates and matches
          preprocessChatData(storedChatMessages);

          // Populate date filter dropdown (which also triggers match filter population)
          populateDateFilters();
          dateSelect.disabled = false; // Enable after populating
          filtersContainer.classList.add('visible'); // Make filters visible

          // Initially render all messages
          renderChatlog(storedChatMessages, true);

        } catch (err) {
          chatlogContainer.innerHTML = `<div class="info-message">Error: Could not parse the JSON file. Please ensure it's valid. (${err.message})</div>`;
          console.error('Error processing file:', err);
          storedChatMessages = [];
          uniqueDates = [];
          matchSegments = [];
          dateSelect.innerHTML = '';
          matchSelect.innerHTML = '';
          dateSelect.disabled = true;
          matchSelect.disabled = true;
          filtersContainer.classList.remove('visible'); // Keep hidden on error
        }
      };
      reader.onerror = function() {
        const errorContainer = document.getElementById('chatlog') || document.body;
        errorContainer.innerHTML = '<div class="info-message">Error: Could not read the file.</div>';
        console.error('Error reading file:', reader.error);
        storedChatMessages = [];
        uniqueDates = [];
        matchSegments = [];
        dateSelect.innerHTML = '';
        matchSelect.innerHTML = '';
        dateSelect.disabled = true;
        matchSelect.disabled = true;
        filtersContainer.classList.remove('visible'); // Keep hidden on error
      };
      reader.readAsText(file);
    });
  </script>
</body>
</html>
